//
// Generated by Bluespec Compiler, version 2023.07-18-g63b2cc2e (build 63b2cc2e)
//
// On Mon Mar 11 10:52:30 -03 2024
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTb(CLK,
	    RST_N);
  input  CLK;
  input  RST_N;

  // inlined wires
  wire lr_fsm_start_wire$whas,
       lr_fsm_state_set_pw$whas,
       start_wire$whas,
       state_set_pw$whas;

  // register cnt
  reg [6 : 0] cnt;
  wire [6 : 0] cnt$D_IN;
  wire cnt$EN;

  // register lr_c
  reg [31 : 0] lr_c;
  wire [31 : 0] lr_c$D_IN;
  wire lr_c$EN;

  // register lr_fsm_start_reg
  reg lr_fsm_start_reg;
  wire lr_fsm_start_reg$D_IN, lr_fsm_start_reg$EN;

  // register lr_fsm_start_reg_1
  reg lr_fsm_start_reg_1;
  wire lr_fsm_start_reg_1$D_IN, lr_fsm_start_reg_1$EN;

  // register lr_fsm_state_can_overlap
  reg lr_fsm_state_can_overlap;
  wire lr_fsm_state_can_overlap$D_IN, lr_fsm_state_can_overlap$EN;

  // register lr_fsm_state_fired
  reg lr_fsm_state_fired;
  wire lr_fsm_state_fired$D_IN, lr_fsm_state_fired$EN;

  // register lr_fsm_state_mkFSMstate
  reg [2 : 0] lr_fsm_state_mkFSMstate;
  reg [2 : 0] lr_fsm_state_mkFSMstate$D_IN;
  wire lr_fsm_state_mkFSMstate$EN;

  // register lr_res
  reg [44 : 0] lr_res;
  wire [44 : 0] lr_res$D_IN;
  wire lr_res$EN;

  // register running
  reg running;
  wire running$D_IN, running$EN;

  // register start_reg
  reg start_reg;
  wire start_reg$D_IN, start_reg$EN;

  // register start_reg_1
  reg start_reg_1;
  wire start_reg_1$D_IN, start_reg_1$EN;

  // register state_can_overlap
  reg state_can_overlap;
  wire state_can_overlap$D_IN, state_can_overlap$EN;

  // register state_fired
  reg state_fired;
  wire state_fired$D_IN, state_fired$EN;

  // register state_mkFSMstate
  reg [3 : 0] state_mkFSMstate;
  reg [3 : 0] state_mkFSMstate$D_IN;
  wire state_mkFSMstate$EN;

  // ports of submodule infifo
  wire [44 : 0] infifo$D_IN, infifo$D_OUT;
  wire infifo$CLR, infifo$DEQ, infifo$EMPTY_N, infifo$ENQ, infifo$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_action_l15c17,
       WILL_FIRE_RL_action_l16c15,
       WILL_FIRE_RL_action_l17c19,
       WILL_FIRE_RL_action_l20c13,
       WILL_FIRE_RL_action_l21c19,
       WILL_FIRE_RL_action_l23c9,
       WILL_FIRE_RL_fsm_start,
       WILL_FIRE_RL_idle_l13c15,
       WILL_FIRE_RL_lr_fsm_action_l44c25,
       WILL_FIRE_RL_lr_fsm_fsm_start,
       WILL_FIRE_RL_lr_fsm_idle_l33c17;

  // inputs to muxes for submodule ports
  wire MUX_start_reg$write_1__SEL_2;

  // declarations used by system tasks
  // synopsys translate_off
  reg [31 : 0] b__h12360;
  // synopsys translate_on

  // remaining internal signals
  wire [43 : 0] IF_lr_res_BIT_44_THEN_lr_res_BITS_43_TO_0_ELSE_0__q1;
  wire [31 : 0] IF_NOT_lr_c_SLT_48_AND_lr_c_SLE_57_THEN_lr_c_M_ETC__q2;
  wire NOT_cnt_19_ULT_3_20_57_AND_start_wire_whas__4__ETC___d159,
       abort_whas__1_AND_abort_wget__2_3_OR_state_mkF_ETC___d177,
       cnt_19_ULT_3___d120,
       lr_fsm_abort_whas_AND_lr_fsm_abort_wget_OR_lr__ETC___d137,
       lr_fsm_abort_whas_AND_lr_fsm_abort_wget_OR_lr__ETC___d82,
       lr_fsm_start_wire_whas_AND_lr_fsm_start_wire_w_ETC___d47;

  // submodule infifo
  SizedFIFO #(.p1width(32'd45),
	      .p2depth(32'd256),
	      .p3cntr_width(32'd8),
	      .guarded(1'd1)) infifo(.RST(RST_N),
				     .CLK(CLK),
				     .D_IN(infifo$D_IN),
				     .ENQ(infifo$ENQ),
				     .DEQ(infifo$DEQ),
				     .CLR(infifo$CLR),
				     .D_OUT(infifo$D_OUT),
				     .FULL_N(infifo$FULL_N),
				     .EMPTY_N(infifo$EMPTY_N));

  // rule RL_action_l16c15
  assign WILL_FIRE_RL_action_l16c15 =
	     lr_fsm_abort_whas_AND_lr_fsm_abort_wget_OR_lr__ETC___d137 &&
	     state_mkFSMstate == 4'd1 ;

  // rule RL_action_l17c19
  assign WILL_FIRE_RL_action_l17c19 =
	     lr_fsm_abort_whas_AND_lr_fsm_abort_wget_OR_lr__ETC___d137 &&
	     infifo$FULL_N &&
	     state_mkFSMstate == 4'd2 ;

  // rule RL_action_l20c13
  assign WILL_FIRE_RL_action_l20c13 =
	     lr_fsm_abort_whas_AND_lr_fsm_abort_wget_OR_lr__ETC___d137 &&
	     infifo$EMPTY_N &&
	     lr_res[44] &&
	     state_mkFSMstate == 4'd3 ;

  // rule RL_action_l21c19
  assign WILL_FIRE_RL_action_l21c19 =
	     infifo$EMPTY_N && state_mkFSMstate == 4'd5 ;

  // rule RL_fsm_start
  assign WILL_FIRE_RL_fsm_start =
	     abort_whas__1_AND_abort_wget__2_3_OR_state_mkF_ETC___d177 &&
	     start_reg ;

  // rule RL_action_l15c17
  assign WILL_FIRE_RL_action_l15c17 =
	     cnt_19_ULT_3___d120 && start_wire$whas &&
	     state_mkFSMstate == 4'd0 ||
	     cnt_19_ULT_3___d120 && state_mkFSMstate == 4'd6 ||
	     cnt_19_ULT_3___d120 && start_wire$whas &&
	     state_mkFSMstate == 4'd7 ;

  // rule RL_action_l23c9
  assign WILL_FIRE_RL_action_l23c9 =
	     (NOT_cnt_19_ULT_3_20_57_AND_start_wire_whas__4__ETC___d159 ||
	      lr_fsm_abort_whas_AND_lr_fsm_abort_wget_OR_lr__ETC___d137) &&
	     (NOT_cnt_19_ULT_3_20_57_AND_start_wire_whas__4__ETC___d159 ||
	      !lr_res[44] && state_mkFSMstate == 4'd3 ||
	      !cnt_19_ULT_3___d120 && state_mkFSMstate == 4'd6 ||
	      !cnt_19_ULT_3___d120 && start_wire$whas &&
	      state_mkFSMstate == 4'd7) ;

  // rule RL_idle_l13c15
  assign WILL_FIRE_RL_idle_l13c15 =
	     (!cnt_19_ULT_3___d120 || !start_wire$whas) &&
	     (cnt_19_ULT_3___d120 || !start_wire$whas) &&
	     state_mkFSMstate == 4'd7 ;

  // rule RL_lr_fsm_action_l44c25
  assign WILL_FIRE_RL_lr_fsm_action_l44c25 =
	     lr_c != 32'd10 && lr_c != 32'd44 &&
	     lr_fsm_state_mkFSMstate == 3'd1 ;

  // rule RL_lr_fsm_fsm_start
  assign WILL_FIRE_RL_lr_fsm_fsm_start =
	     lr_fsm_abort_whas_AND_lr_fsm_abort_wget_OR_lr__ETC___d82 &&
	     (!lr_fsm_start_reg_1 || lr_fsm_state_fired) &&
	     lr_fsm_start_reg ;

  // rule RL_lr_fsm_idle_l33c17
  assign WILL_FIRE_RL_lr_fsm_idle_l33c17 =
	     (lr_c == 32'd10 || lr_c == 32'd44) && !lr_fsm_start_wire$whas &&
	     lr_fsm_state_mkFSMstate == 3'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_start_reg$write_1__SEL_2 =
	     abort_whas__1_AND_abort_wget__2_3_OR_state_mkF_ETC___d177 &&
	     !start_reg &&
	     !running ;

  // inlined wires
  assign lr_fsm_start_wire$whas =
	     WILL_FIRE_RL_lr_fsm_fsm_start ||
	     lr_fsm_start_reg_1 && !lr_fsm_state_fired ;
  assign start_wire$whas =
	     WILL_FIRE_RL_fsm_start || start_reg_1 && !state_fired ;
  assign lr_fsm_state_set_pw$whas =
	     WILL_FIRE_RL_lr_fsm_idle_l33c17 ||
	     WILL_FIRE_RL_lr_fsm_action_l44c25 ||
	     lr_fsm_start_wire_whas_AND_lr_fsm_start_wire_w_ETC___d47 ;
  assign state_set_pw$whas =
	     WILL_FIRE_RL_idle_l13c15 || WILL_FIRE_RL_action_l23c9 ||
	     WILL_FIRE_RL_action_l21c19 ||
	     WILL_FIRE_RL_action_l20c13 ||
	     WILL_FIRE_RL_action_l17c19 ||
	     WILL_FIRE_RL_action_l16c15 ||
	     WILL_FIRE_RL_action_l15c17 ;

  // register cnt
  assign cnt$D_IN = cnt + 7'd1 ;
  assign cnt$EN = WILL_FIRE_RL_action_l15c17 ;

  // register lr_c
  assign lr_c$D_IN = b__h12360 ;
  assign lr_c$EN = lr_fsm_start_wire_whas_AND_lr_fsm_start_wire_w_ETC___d47 ;

  // register lr_fsm_start_reg
  assign lr_fsm_start_reg$D_IN = !WILL_FIRE_RL_lr_fsm_fsm_start ;
  assign lr_fsm_start_reg$EN =
	     WILL_FIRE_RL_lr_fsm_fsm_start || WILL_FIRE_RL_action_l16c15 ;

  // register lr_fsm_start_reg_1
  assign lr_fsm_start_reg_1$D_IN = lr_fsm_start_wire$whas ;
  assign lr_fsm_start_reg_1$EN = 1'd1 ;

  // register lr_fsm_state_can_overlap
  assign lr_fsm_state_can_overlap$D_IN =
	     lr_fsm_state_set_pw$whas || lr_fsm_state_can_overlap ;
  assign lr_fsm_state_can_overlap$EN = 1'd1 ;

  // register lr_fsm_state_fired
  assign lr_fsm_state_fired$D_IN = lr_fsm_state_set_pw$whas ;
  assign lr_fsm_state_fired$EN = 1'd1 ;

  // register lr_fsm_state_mkFSMstate
  always@(WILL_FIRE_RL_lr_fsm_idle_l33c17 or
	  lr_fsm_start_wire_whas_AND_lr_fsm_start_wire_w_ETC___d47 or
	  WILL_FIRE_RL_lr_fsm_action_l44c25)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_lr_fsm_idle_l33c17: lr_fsm_state_mkFSMstate$D_IN = 3'd0;
      lr_fsm_start_wire_whas_AND_lr_fsm_start_wire_w_ETC___d47:
	  lr_fsm_state_mkFSMstate$D_IN = 3'd1;
      WILL_FIRE_RL_lr_fsm_action_l44c25: lr_fsm_state_mkFSMstate$D_IN = 3'd3;
      default: lr_fsm_state_mkFSMstate$D_IN = 3'bxxx /* unspecified value */ ;
    endcase
  end
  assign lr_fsm_state_mkFSMstate$EN =
	     WILL_FIRE_RL_lr_fsm_idle_l33c17 ||
	     lr_fsm_start_wire_whas_AND_lr_fsm_start_wire_w_ETC___d47 ||
	     WILL_FIRE_RL_lr_fsm_action_l44c25 ;

  // register lr_res
  assign lr_res$D_IN =
	     { lr_c != 32'd95,
	       IF_lr_res_BIT_44_THEN_lr_res_BITS_43_TO_0_ELSE_0__q1[39:0],
	       IF_NOT_lr_c_SLT_48_AND_lr_c_SLE_57_THEN_lr_c_M_ETC__q2[3:0] } ;
  assign lr_res$EN =
	     WILL_FIRE_RL_lr_fsm_action_l44c25 && lr_c != 32'd9 &&
	     lr_c != 32'd32 ;

  // register running
  assign running$D_IN = 1'd1 ;
  assign running$EN = MUX_start_reg$write_1__SEL_2 ;

  // register start_reg
  assign start_reg$D_IN = !WILL_FIRE_RL_fsm_start ;
  assign start_reg$EN =
	     WILL_FIRE_RL_fsm_start ||
	     abort_whas__1_AND_abort_wget__2_3_OR_state_mkF_ETC___d177 &&
	     !start_reg &&
	     !running ;

  // register start_reg_1
  assign start_reg_1$D_IN = start_wire$whas ;
  assign start_reg_1$EN = 1'd1 ;

  // register state_can_overlap
  assign state_can_overlap$D_IN = state_set_pw$whas || state_can_overlap ;
  assign state_can_overlap$EN = 1'd1 ;

  // register state_fired
  assign state_fired$D_IN = state_set_pw$whas ;
  assign state_fired$EN = 1'd1 ;

  // register state_mkFSMstate
  always@(WILL_FIRE_RL_idle_l13c15 or
	  WILL_FIRE_RL_action_l15c17 or
	  WILL_FIRE_RL_action_l16c15 or
	  WILL_FIRE_RL_action_l17c19 or
	  WILL_FIRE_RL_action_l20c13 or
	  WILL_FIRE_RL_action_l21c19 or WILL_FIRE_RL_action_l23c9)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_idle_l13c15: state_mkFSMstate$D_IN = 4'd0;
      WILL_FIRE_RL_action_l15c17: state_mkFSMstate$D_IN = 4'd1;
      WILL_FIRE_RL_action_l16c15: state_mkFSMstate$D_IN = 4'd2;
      WILL_FIRE_RL_action_l17c19: state_mkFSMstate$D_IN = 4'd3;
      WILL_FIRE_RL_action_l20c13: state_mkFSMstate$D_IN = 4'd5;
      WILL_FIRE_RL_action_l21c19: state_mkFSMstate$D_IN = 4'd6;
      WILL_FIRE_RL_action_l23c9: state_mkFSMstate$D_IN = 4'd7;
      default: state_mkFSMstate$D_IN = 4'bxxxx /* unspecified value */ ;
    endcase
  end
  assign state_mkFSMstate$EN =
	     WILL_FIRE_RL_idle_l13c15 || WILL_FIRE_RL_action_l15c17 ||
	     WILL_FIRE_RL_action_l16c15 ||
	     WILL_FIRE_RL_action_l17c19 ||
	     WILL_FIRE_RL_action_l20c13 ||
	     WILL_FIRE_RL_action_l21c19 ||
	     WILL_FIRE_RL_action_l23c9 ;

  // submodule infifo
  assign infifo$D_IN = lr_res ;
  assign infifo$ENQ = WILL_FIRE_RL_action_l17c19 ;
  assign infifo$DEQ = WILL_FIRE_RL_action_l21c19 ;
  assign infifo$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_NOT_lr_c_SLT_48_AND_lr_c_SLE_57_THEN_lr_c_M_ETC__q2 =
	     ((lr_c ^ 32'h80000000) >= 32'h80000030 &&
	      (lr_c ^ 32'h80000000) <= 32'h80000039) ?
	       lr_c - 32'd48 :
	       ((lr_c == 32'd45) ? 32'd15 : 32'd14) ;
  assign IF_lr_res_BIT_44_THEN_lr_res_BITS_43_TO_0_ELSE_0__q1 =
	     lr_res[44] ? lr_res[43:0] : 44'd0 ;
  assign NOT_cnt_19_ULT_3_20_57_AND_start_wire_whas__4__ETC___d159 =
	     !cnt_19_ULT_3___d120 && start_wire$whas &&
	     state_mkFSMstate == 4'd0 ;
  assign abort_whas__1_AND_abort_wget__2_3_OR_state_mkF_ETC___d177 =
	     (state_mkFSMstate == 4'd0 || state_mkFSMstate == 4'd7) &&
	     (!start_reg_1 || state_fired) ;
  assign cnt_19_ULT_3___d120 = cnt < 7'd3 ;
  assign lr_fsm_abort_whas_AND_lr_fsm_abort_wget_OR_lr__ETC___d137 =
	     lr_fsm_abort_whas_AND_lr_fsm_abort_wget_OR_lr__ETC___d82 &&
	     (!lr_fsm_start_reg_1 || lr_fsm_state_fired) &&
	     !lr_fsm_start_reg ;
  assign lr_fsm_abort_whas_AND_lr_fsm_abort_wget_OR_lr__ETC___d82 =
	     lr_fsm_state_mkFSMstate == 3'd0 ||
	     (lr_c == 32'd10 || lr_c == 32'd44) &&
	     lr_fsm_state_mkFSMstate == 3'd1 ;
  assign lr_fsm_start_wire_whas_AND_lr_fsm_start_wire_w_ETC___d47 =
	     lr_fsm_start_wire$whas && lr_fsm_state_mkFSMstate == 3'd0 ||
	     (lr_c == 32'd10 || lr_c == 32'd44) && lr_fsm_start_wire$whas &&
	     lr_fsm_state_mkFSMstate == 3'd1 ||
	     lr_fsm_state_mkFSMstate == 3'd3 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        cnt <= `BSV_ASSIGNMENT_DELAY 7'd0;
	lr_fsm_start_reg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	lr_fsm_start_reg_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	lr_fsm_state_can_overlap <= `BSV_ASSIGNMENT_DELAY 1'd1;
	lr_fsm_state_fired <= `BSV_ASSIGNMENT_DELAY 1'd0;
	lr_fsm_state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY 3'd0;
	running <= `BSV_ASSIGNMENT_DELAY 1'd0;
	start_reg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	start_reg_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	state_can_overlap <= `BSV_ASSIGNMENT_DELAY 1'd1;
	state_fired <= `BSV_ASSIGNMENT_DELAY 1'd0;
	state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY 4'd0;
      end
    else
      begin
        if (cnt$EN) cnt <= `BSV_ASSIGNMENT_DELAY cnt$D_IN;
	if (lr_fsm_start_reg$EN)
	  lr_fsm_start_reg <= `BSV_ASSIGNMENT_DELAY lr_fsm_start_reg$D_IN;
	if (lr_fsm_start_reg_1$EN)
	  lr_fsm_start_reg_1 <= `BSV_ASSIGNMENT_DELAY lr_fsm_start_reg_1$D_IN;
	if (lr_fsm_state_can_overlap$EN)
	  lr_fsm_state_can_overlap <= `BSV_ASSIGNMENT_DELAY
	      lr_fsm_state_can_overlap$D_IN;
	if (lr_fsm_state_fired$EN)
	  lr_fsm_state_fired <= `BSV_ASSIGNMENT_DELAY lr_fsm_state_fired$D_IN;
	if (lr_fsm_state_mkFSMstate$EN)
	  lr_fsm_state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY
	      lr_fsm_state_mkFSMstate$D_IN;
	if (running$EN) running <= `BSV_ASSIGNMENT_DELAY running$D_IN;
	if (start_reg$EN) start_reg <= `BSV_ASSIGNMENT_DELAY start_reg$D_IN;
	if (start_reg_1$EN)
	  start_reg_1 <= `BSV_ASSIGNMENT_DELAY start_reg_1$D_IN;
	if (state_can_overlap$EN)
	  state_can_overlap <= `BSV_ASSIGNMENT_DELAY state_can_overlap$D_IN;
	if (state_fired$EN)
	  state_fired <= `BSV_ASSIGNMENT_DELAY state_fired$D_IN;
	if (state_mkFSMstate$EN)
	  state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY state_mkFSMstate$D_IN;
      end
    if (lr_c$EN) lr_c <= `BSV_ASSIGNMENT_DELAY lr_c$D_IN;
    if (lr_res$EN) lr_res <= `BSV_ASSIGNMENT_DELAY lr_res$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    cnt = 7'h2A;
    lr_c = 32'hAAAAAAAA;
    lr_fsm_start_reg = 1'h0;
    lr_fsm_start_reg_1 = 1'h0;
    lr_fsm_state_can_overlap = 1'h0;
    lr_fsm_state_fired = 1'h0;
    lr_fsm_state_mkFSMstate = 3'h2;
    lr_res = 45'h0AAAAAAAAAAA;
    running = 1'h0;
    start_reg = 1'h0;
    start_reg_1 = 1'h0;
    state_can_overlap = 1'h0;
    state_fired = 1'h0;
    state_mkFSMstate = 4'hA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l20c13)
	$write($unsigned(cnt), ": ", infifo$D_OUT);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l23c9) $finish(32'd0);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l15c17 &&
	  (WILL_FIRE_RL_action_l16c15 || WILL_FIRE_RL_action_l17c19 ||
	   WILL_FIRE_RL_action_l20c13 ||
	   WILL_FIRE_RL_action_l21c19 ||
	   WILL_FIRE_RL_action_l23c9))
	$display("Error: \"Tb.bsv\", line 15, column 17: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l15c17] and\n  [RL_action_l16c15, RL_action_l17c19, RL_action_l20c13, RL_action_l21c19,\n  RL_action_l23c9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l16c15 &&
	  (WILL_FIRE_RL_action_l17c19 || WILL_FIRE_RL_action_l20c13 ||
	   WILL_FIRE_RL_action_l21c19 ||
	   WILL_FIRE_RL_action_l23c9))
	$display("Error: \"Tb.bsv\", line 16, column 15: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l16c15] and\n  [RL_action_l17c19, RL_action_l20c13, RL_action_l21c19, RL_action_l23c9] )\n  fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l17c19 &&
	  (WILL_FIRE_RL_action_l20c13 || WILL_FIRE_RL_action_l21c19 ||
	   WILL_FIRE_RL_action_l23c9))
	$display("Error: \"Tb.bsv\", line 17, column 19: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l17c19] and\n  [RL_action_l20c13, RL_action_l21c19, RL_action_l23c9] ) fired in the same\n  clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l20c13 &&
	  (WILL_FIRE_RL_action_l21c19 || WILL_FIRE_RL_action_l23c9))
	$display("Error: \"Tb.bsv\", line 20, column 13: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l20c13] and\n  [RL_action_l21c19, RL_action_l23c9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l21c19 && WILL_FIRE_RL_action_l23c9)
	$display("Error: \"Tb.bsv\", line 21, column 19: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l21c19] and\n  [RL_action_l23c9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (running &&
	  abort_whas__1_AND_abort_wget__2_3_OR_state_mkF_ETC___d177 &&
	  !start_reg)
	$finish(32'd0);
    if (RST_N != `BSV_RESET_VALUE)
      if (lr_fsm_start_wire_whas_AND_lr_fsm_start_wire_w_ETC___d47)
	begin
	  b__h12360 = $fgetc(32'h80000000);
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (lr_fsm_start_wire_whas_AND_lr_fsm_start_wire_w_ETC___d47 &&
	  b__h12360 == 32'hFFFFFFFF)
	$display("Unexpected EOF");
    if (RST_N != `BSV_RESET_VALUE)
      if (lr_fsm_start_wire_whas_AND_lr_fsm_start_wire_w_ETC___d47 &&
	  b__h12360 == 32'hFFFFFFFF)
	$finish(32'd1);
    if (RST_N != `BSV_RESET_VALUE)
      if (lr_fsm_start_wire_whas_AND_lr_fsm_start_wire_w_ETC___d47 &&
	  WILL_FIRE_RL_lr_fsm_action_l44c25)
	$display("Error: \"FileOps.bsv\", line 34, column 25: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_lr_fsm_action_l34c25] and\n  [RL_lr_fsm_action_l44c25] ) fired in the same clock cycle.\n");
  end
  // synopsys translate_on
endmodule  // mkTb

