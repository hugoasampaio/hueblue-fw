//
// Generated by Bluespec Compiler, version 2024.01-9-gc481d7f5 (build c481d7f5)
//
// On Sun May 26 00:21:57 -03 2024
//
//
// Ports:
// Name                         I/O  size props
// RDY_addSample                  O     1 reg
// getFixedSample                 O    48 reg
// RDY_getFixedSample             O     1 reg
// getError                       O    24 reg
// RDY_getError                   O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// addSample_ns                   I    48 reg
// EN_addSample                   I     1
// EN_getFixedSample              I     1
// EN_getError                    I     1 unused
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkCostasLoopO(CLK,
		     RST_N,

		     addSample_ns,
		     EN_addSample,
		     RDY_addSample,

		     EN_getFixedSample,
		     getFixedSample,
		     RDY_getFixedSample,

		     EN_getError,
		     getError,
		     RDY_getError);
  input  CLK;
  input  RST_N;

  // action method addSample
  input  [47 : 0] addSample_ns;
  input  EN_addSample;
  output RDY_addSample;

  // actionvalue method getFixedSample
  input  EN_getFixedSample;
  output [47 : 0] getFixedSample;
  output RDY_getFixedSample;

  // actionvalue method getError
  input  EN_getError;
  output [23 : 0] getError;
  output RDY_getError;

  // signals for module outputs
  wire [47 : 0] getFixedSample;
  wire [23 : 0] getError;
  wire RDY_addSample, RDY_getError, RDY_getFixedSample;

  // inlined wires
  wire costasL_start_wire$whas, costasL_state_set_pw$whas;

  // register costasL_start_reg
  reg costasL_start_reg;
  wire costasL_start_reg$D_IN, costasL_start_reg$EN;

  // register costasL_start_reg_1
  reg costasL_start_reg_1;
  wire costasL_start_reg_1$D_IN, costasL_start_reg_1$EN;

  // register costasL_state_can_overlap
  reg costasL_state_can_overlap;
  wire costasL_state_can_overlap$D_IN, costasL_state_can_overlap$EN;

  // register costasL_state_fired
  reg costasL_state_fired;
  wire costasL_state_fired$D_IN, costasL_state_fired$EN;

  // register costasL_state_mkFSMstate
  reg [3 : 0] costasL_state_mkFSMstate;
  reg [3 : 0] costasL_state_mkFSMstate$D_IN;
  wire costasL_state_mkFSMstate$EN;

  // register error
  reg [23 : 0] error;
  wire [23 : 0] error$D_IN;
  wire error$EN;

  // register freq
  reg [23 : 0] freq;
  wire [23 : 0] freq$D_IN;
  wire freq$EN;

  // register phase
  reg [23 : 0] phase;
  reg [23 : 0] phase$D_IN;
  wire phase$EN;

  // register sample
  reg [47 : 0] sample;
  wire [47 : 0] sample$D_IN;
  wire sample$EN;

  // ports of submodule fixFxError
  wire [23 : 0] fixFxError$getX,
		fixFxError$getY,
		fixFxError$setPolar_x,
		fixFxError$setPolar_y,
		fixFxError$setPolar_z;
  wire fixFxError$EN_getX,
       fixFxError$EN_getY,
       fixFxError$EN_setPolar,
       fixFxError$RDY_getX,
       fixFxError$RDY_getY,
       fixFxError$RDY_setPolar;

  // ports of submodule inSample
  wire [47 : 0] inSample$D_IN, inSample$D_OUT;
  wire inSample$CLR,
       inSample$DEQ,
       inSample$EMPTY_N,
       inSample$ENQ,
       inSample$FULL_N;

  // ports of submodule outSample
  wire [47 : 0] outSample$D_IN, outSample$D_OUT;
  wire outSample$CLR,
       outSample$DEQ,
       outSample$EMPTY_N,
       outSample$ENQ,
       outSample$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_costasL_action_l36c19,
       WILL_FIRE_RL_costasL_action_l37c17,
       WILL_FIRE_RL_costasL_action_l38c9,
       WILL_FIRE_RL_costasL_action_l42c9,
       WILL_FIRE_RL_costasL_action_l46c18,
       WILL_FIRE_RL_costasL_action_l53c19,
       WILL_FIRE_RL_costasL_action_l57c19,
       WILL_FIRE_RL_costasL_fsm_start,
       WILL_FIRE_RL_costasL_idle_l34c22,
       WILL_FIRE_RL_costasL_idle_l34c22_1,
       WILL_FIRE_RL_costasL_idle_l34c22_2;

  // inputs to muxes for submodule ports
  wire [47 : 0] MUX_sample$write_1__VAL_1, MUX_sample$write_1__VAL_2;
  wire [23 : 0] MUX_phase$write_1__VAL_1,
		MUX_phase$write_1__VAL_2,
		MUX_phase$write_1__VAL_3;
  wire MUX_costasL_state_mkFSMstate$write_1__SEL_1;

  // remaining internal signals
  wire [47 : 0] IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d143,
		IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d182,
		IF_error_37_BIT_23_38_THEN_NEG_error_37_39_ELS_ETC___d141,
		IF_error_37_BIT_23_38_THEN_NEG_error_37_39_ELS_ETC___d180,
		IF_sample_2_BIT_47_8_THEN_NEG_sample_2_BITS_47_ETC___d99,
		x__h34000;
  wire [35 : 0] IF_NOT_IF_error_37_BIT_23_38_THEN_NEG_IF_error_ETC___d158,
		IF_NOT_IF_error_37_BIT_23_38_THEN_NEG_IF_error_ETC___d197,
		IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d155,
		IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d194,
		IF_sample_2_BIT_47_8_AND_NOT_sample_2_BIT_23_9_ETC___d113,
		x__h33671;
  wire [23 : 0] x__h34045, x__h34064, x__h39380, x__h40150;
  wire [11 : 0] y_f__h34893, y_f__h37937, y_f__h40992;
  wire costasL_abort_whas_AND_costasL_abort_wget_OR_c_ETC___d237,
       phase_0_SLE_6433___d41,
       phase_0_SLT_16770783___d42;

  // action method addSample
  assign RDY_addSample = inSample$FULL_N ;

  // actionvalue method getFixedSample
  assign getFixedSample = outSample$D_OUT ;
  assign RDY_getFixedSample = outSample$EMPTY_N ;

  // actionvalue method getError
  assign getError = error ;
  assign RDY_getError = 1'd1 ;

  // submodule fixFxError
  mkRotate fixFxError(.CLK(CLK),
		      .RST_N(RST_N),
		      .setPolar_x(fixFxError$setPolar_x),
		      .setPolar_y(fixFxError$setPolar_y),
		      .setPolar_z(fixFxError$setPolar_z),
		      .EN_setPolar(fixFxError$EN_setPolar),
		      .EN_getX(fixFxError$EN_getX),
		      .EN_getY(fixFxError$EN_getY),
		      .RDY_setPolar(fixFxError$RDY_setPolar),
		      .getX(fixFxError$getX),
		      .RDY_getX(fixFxError$RDY_getX),
		      .getY(fixFxError$getY),
		      .RDY_getY(fixFxError$RDY_getY));

  // submodule inSample
  FIFO2 #(.width(32'd48), .guarded(1'd1)) inSample(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(inSample$D_IN),
						   .ENQ(inSample$ENQ),
						   .DEQ(inSample$DEQ),
						   .CLR(inSample$CLR),
						   .D_OUT(inSample$D_OUT),
						   .FULL_N(inSample$FULL_N),
						   .EMPTY_N(inSample$EMPTY_N));

  // submodule outSample
  FIFO2 #(.width(32'd48), .guarded(1'd1)) outSample(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(outSample$D_IN),
						    .ENQ(outSample$ENQ),
						    .DEQ(outSample$DEQ),
						    .CLR(outSample$CLR),
						    .D_OUT(outSample$D_OUT),
						    .FULL_N(outSample$FULL_N),
						    .EMPTY_N(outSample$EMPTY_N));

  // rule RL_costasL_action_l37c17
  assign WILL_FIRE_RL_costasL_action_l37c17 =
	     inSample$EMPTY_N && costasL_state_mkFSMstate == 4'd1 ;

  // rule RL_costasL_action_l38c9
  assign WILL_FIRE_RL_costasL_action_l38c9 =
	     fixFxError$RDY_getX && costasL_state_mkFSMstate == 4'd2 ;

  // rule RL_costasL_action_l42c9
  assign WILL_FIRE_RL_costasL_action_l42c9 =
	     fixFxError$RDY_getY && costasL_state_mkFSMstate == 4'd3 ;

  // rule RL_costasL_action_l46c18
  assign WILL_FIRE_RL_costasL_action_l46c18 =
	     outSample$FULL_N && costasL_state_mkFSMstate == 4'd4 ;

  // rule RL_costasL_action_l53c19
  assign WILL_FIRE_RL_costasL_action_l53c19 =
	     !phase_0_SLE_6433___d41 &&
	     (costasL_state_mkFSMstate == 4'd8 ||
	      costasL_state_mkFSMstate == 4'd9) ;

  // rule RL_costasL_fsm_start
  assign WILL_FIRE_RL_costasL_fsm_start =
	     costasL_abort_whas_AND_costasL_abort_wget_OR_c_ETC___d237 &&
	     (!costasL_start_reg_1 || costasL_state_fired) &&
	     costasL_start_reg ;

  // rule RL_costasL_action_l36c19
  assign WILL_FIRE_RL_costasL_action_l36c19 =
	     fixFxError$RDY_setPolar && inSample$EMPTY_N &&
	     (costasL_start_wire$whas && costasL_state_mkFSMstate == 4'd0 ||
	      phase_0_SLE_6433___d41 && !phase_0_SLT_16770783___d42 &&
	      costasL_start_wire$whas &&
	      costasL_state_mkFSMstate == 4'd8 ||
	      phase_0_SLE_6433___d41 && !phase_0_SLT_16770783___d42 &&
	      costasL_start_wire$whas &&
	      costasL_state_mkFSMstate == 4'd9 ||
	      !phase_0_SLT_16770783___d42 && costasL_start_wire$whas &&
	      costasL_state_mkFSMstate == 4'd10) ;

  // rule RL_costasL_action_l57c19
  assign WILL_FIRE_RL_costasL_action_l57c19 =
	     phase_0_SLE_6433___d41 && phase_0_SLT_16770783___d42 &&
	     (costasL_state_mkFSMstate == 4'd8 ||
	      costasL_state_mkFSMstate == 4'd9) ||
	     phase_0_SLT_16770783___d42 && costasL_state_mkFSMstate == 4'd10 ;

  // rule RL_costasL_idle_l34c22
  assign WILL_FIRE_RL_costasL_idle_l34c22 =
	     phase_0_SLE_6433___d41 && !phase_0_SLT_16770783___d42 &&
	     !costasL_start_wire$whas &&
	     costasL_state_mkFSMstate == 4'd8 ;

  // rule RL_costasL_idle_l34c22_1
  assign WILL_FIRE_RL_costasL_idle_l34c22_1 =
	     phase_0_SLE_6433___d41 && !phase_0_SLT_16770783___d42 &&
	     !costasL_start_wire$whas &&
	     costasL_state_mkFSMstate == 4'd9 ;

  // rule RL_costasL_idle_l34c22_2
  assign WILL_FIRE_RL_costasL_idle_l34c22_2 =
	     !phase_0_SLT_16770783___d42 && !costasL_start_wire$whas &&
	     costasL_state_mkFSMstate == 4'd10 ;

  // inputs to muxes for submodule ports
  assign MUX_costasL_state_mkFSMstate$write_1__SEL_1 =
	     WILL_FIRE_RL_costasL_idle_l34c22_2 ||
	     WILL_FIRE_RL_costasL_idle_l34c22_1 ||
	     WILL_FIRE_RL_costasL_idle_l34c22 ;
  assign MUX_phase$write_1__VAL_1 = phase + 24'd6433 ;
  assign MUX_phase$write_1__VAL_2 =
	     x__h39380 +
	     ((!IF_NOT_IF_error_37_BIT_23_38_THEN_NEG_IF_error_ETC___d197[35] &&
	       (IF_NOT_IF_error_37_BIT_23_38_THEN_NEG_IF_error_ETC___d197[23] ||
		IF_NOT_IF_error_37_BIT_23_38_THEN_NEG_IF_error_ETC___d197[35:24] !=
		12'd0)) ?
		24'd8388607 :
		((IF_NOT_IF_error_37_BIT_23_38_THEN_NEG_IF_error_ETC___d197[35] &&
		  (!IF_NOT_IF_error_37_BIT_23_38_THEN_NEG_IF_error_ETC___d197[23] ||
		   ~IF_NOT_IF_error_37_BIT_23_38_THEN_NEG_IF_error_ETC___d197[35:24] !=
		   12'd0)) ?
		   24'd8388608 :
		   IF_NOT_IF_error_37_BIT_23_38_THEN_NEG_IF_error_ETC___d197[23:0])) ;
  assign MUX_phase$write_1__VAL_3 = phase - 24'd6433 ;
  assign MUX_sample$write_1__VAL_1 = { fixFxError$getX, sample[23:0] } ;
  assign MUX_sample$write_1__VAL_2 = { sample[47:24], fixFxError$getY } ;

  // inlined wires
  assign costasL_start_wire$whas =
	     WILL_FIRE_RL_costasL_fsm_start ||
	     costasL_start_reg_1 && !costasL_state_fired ;
  assign costasL_state_set_pw$whas =
	     WILL_FIRE_RL_costasL_idle_l34c22_2 ||
	     WILL_FIRE_RL_costasL_idle_l34c22_1 ||
	     WILL_FIRE_RL_costasL_idle_l34c22 ||
	     WILL_FIRE_RL_costasL_action_l57c19 ||
	     WILL_FIRE_RL_costasL_action_l53c19 ||
	     costasL_state_mkFSMstate == 4'd7 ||
	     costasL_state_mkFSMstate == 4'd6 ||
	     costasL_state_mkFSMstate == 4'd5 ||
	     WILL_FIRE_RL_costasL_action_l46c18 ||
	     WILL_FIRE_RL_costasL_action_l42c9 ||
	     WILL_FIRE_RL_costasL_action_l38c9 ||
	     WILL_FIRE_RL_costasL_action_l37c17 ||
	     WILL_FIRE_RL_costasL_action_l36c19 ;

  // register costasL_start_reg
  assign costasL_start_reg$D_IN = !WILL_FIRE_RL_costasL_fsm_start ;
  assign costasL_start_reg$EN =
	     WILL_FIRE_RL_costasL_fsm_start ||
	     costasL_abort_whas_AND_costasL_abort_wget_OR_c_ETC___d237 &&
	     (!costasL_start_reg_1 || costasL_state_fired) &&
	     !costasL_start_reg ;

  // register costasL_start_reg_1
  assign costasL_start_reg_1$D_IN = costasL_start_wire$whas ;
  assign costasL_start_reg_1$EN = 1'd1 ;

  // register costasL_state_can_overlap
  assign costasL_state_can_overlap$D_IN =
	     costasL_state_set_pw$whas || costasL_state_can_overlap ;
  assign costasL_state_can_overlap$EN = 1'd1 ;

  // register costasL_state_fired
  assign costasL_state_fired$D_IN = costasL_state_set_pw$whas ;
  assign costasL_state_fired$EN = 1'd1 ;

  // register costasL_state_mkFSMstate
  always@(MUX_costasL_state_mkFSMstate$write_1__SEL_1 or
	  WILL_FIRE_RL_costasL_action_l36c19 or
	  WILL_FIRE_RL_costasL_action_l37c17 or
	  WILL_FIRE_RL_costasL_action_l38c9 or
	  WILL_FIRE_RL_costasL_action_l42c9 or
	  WILL_FIRE_RL_costasL_action_l46c18 or
	  costasL_state_mkFSMstate or
	  WILL_FIRE_RL_costasL_action_l53c19 or
	  WILL_FIRE_RL_costasL_action_l57c19)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_costasL_state_mkFSMstate$write_1__SEL_1:
	  costasL_state_mkFSMstate$D_IN = 4'd0;
      WILL_FIRE_RL_costasL_action_l36c19:
	  costasL_state_mkFSMstate$D_IN = 4'd1;
      WILL_FIRE_RL_costasL_action_l37c17:
	  costasL_state_mkFSMstate$D_IN = 4'd2;
      WILL_FIRE_RL_costasL_action_l38c9: costasL_state_mkFSMstate$D_IN = 4'd3;
      WILL_FIRE_RL_costasL_action_l42c9: costasL_state_mkFSMstate$D_IN = 4'd4;
      WILL_FIRE_RL_costasL_action_l46c18:
	  costasL_state_mkFSMstate$D_IN = 4'd5;
      costasL_state_mkFSMstate == 4'd5: costasL_state_mkFSMstate$D_IN = 4'd6;
      costasL_state_mkFSMstate == 4'd6: costasL_state_mkFSMstate$D_IN = 4'd7;
      costasL_state_mkFSMstate == 4'd7: costasL_state_mkFSMstate$D_IN = 4'd8;
      WILL_FIRE_RL_costasL_action_l53c19:
	  costasL_state_mkFSMstate$D_IN = 4'd9;
      WILL_FIRE_RL_costasL_action_l57c19:
	  costasL_state_mkFSMstate$D_IN = 4'd10;
      default: costasL_state_mkFSMstate$D_IN =
		   4'bxxxx /* unspecified value */ ;
    endcase
  end
  assign costasL_state_mkFSMstate$EN =
	     WILL_FIRE_RL_costasL_idle_l34c22_2 ||
	     WILL_FIRE_RL_costasL_idle_l34c22_1 ||
	     WILL_FIRE_RL_costasL_idle_l34c22 ||
	     WILL_FIRE_RL_costasL_action_l36c19 ||
	     WILL_FIRE_RL_costasL_action_l37c17 ||
	     WILL_FIRE_RL_costasL_action_l38c9 ||
	     WILL_FIRE_RL_costasL_action_l42c9 ||
	     WILL_FIRE_RL_costasL_action_l46c18 ||
	     costasL_state_mkFSMstate == 4'd5 ||
	     costasL_state_mkFSMstate == 4'd6 ||
	     costasL_state_mkFSMstate == 4'd7 ||
	     WILL_FIRE_RL_costasL_action_l53c19 ||
	     WILL_FIRE_RL_costasL_action_l57c19 ;

  // register error
  assign error$D_IN =
	     (!x__h33671[35] &&
	      (x__h33671[23] || x__h33671[35:24] != 12'd0)) ?
	       24'd8388607 :
	       ((x__h33671[35] &&
		 (!x__h33671[23] || ~x__h33671[35:24] != 12'd0)) ?
		  24'd8388608 :
		  x__h33671[23:0]) ;
  assign error$EN = costasL_state_mkFSMstate == 4'd5 ;

  // register freq
  assign freq$D_IN =
	     freq +
	     ((!IF_NOT_IF_error_37_BIT_23_38_THEN_NEG_IF_error_ETC___d158[35] &&
	       (IF_NOT_IF_error_37_BIT_23_38_THEN_NEG_IF_error_ETC___d158[23] ||
		IF_NOT_IF_error_37_BIT_23_38_THEN_NEG_IF_error_ETC___d158[35:24] !=
		12'd0)) ?
		24'd8388607 :
		((IF_NOT_IF_error_37_BIT_23_38_THEN_NEG_IF_error_ETC___d158[35] &&
		  (!IF_NOT_IF_error_37_BIT_23_38_THEN_NEG_IF_error_ETC___d158[23] ||
		   ~IF_NOT_IF_error_37_BIT_23_38_THEN_NEG_IF_error_ETC___d158[35:24] !=
		   12'd0)) ?
		   24'd8388608 :
		   IF_NOT_IF_error_37_BIT_23_38_THEN_NEG_IF_error_ETC___d158[23:0])) ;
  assign freq$EN = costasL_state_mkFSMstate == 4'd6 ;

  // register phase
  always@(WILL_FIRE_RL_costasL_action_l57c19 or
	  MUX_phase$write_1__VAL_1 or
	  costasL_state_mkFSMstate or
	  MUX_phase$write_1__VAL_2 or
	  WILL_FIRE_RL_costasL_action_l53c19 or MUX_phase$write_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_costasL_action_l57c19:
	  phase$D_IN = MUX_phase$write_1__VAL_1;
      costasL_state_mkFSMstate == 4'd7: phase$D_IN = MUX_phase$write_1__VAL_2;
      WILL_FIRE_RL_costasL_action_l53c19:
	  phase$D_IN = MUX_phase$write_1__VAL_3;
      default: phase$D_IN =
		   24'bxxxxxxxxxxxxxxxxxxxxxxxx /* unspecified value */ ;
    endcase
  end
  assign phase$EN =
	     WILL_FIRE_RL_costasL_action_l57c19 ||
	     costasL_state_mkFSMstate == 4'd7 ||
	     WILL_FIRE_RL_costasL_action_l53c19 ;

  // register sample
  assign sample$D_IN =
	     WILL_FIRE_RL_costasL_action_l38c9 ?
	       MUX_sample$write_1__VAL_1 :
	       MUX_sample$write_1__VAL_2 ;
  assign sample$EN =
	     WILL_FIRE_RL_costasL_action_l38c9 ||
	     WILL_FIRE_RL_costasL_action_l42c9 ;

  // submodule fixFxError
  assign fixFxError$setPolar_x = inSample$D_OUT[47:24] ;
  assign fixFxError$setPolar_y = inSample$D_OUT[23:0] ;
  assign fixFxError$setPolar_z = 24'd0 - phase ;
  assign fixFxError$EN_setPolar = WILL_FIRE_RL_costasL_action_l36c19 ;
  assign fixFxError$EN_getX = WILL_FIRE_RL_costasL_action_l38c9 ;
  assign fixFxError$EN_getY = WILL_FIRE_RL_costasL_action_l42c9 ;

  // submodule inSample
  assign inSample$D_IN = addSample_ns ;
  assign inSample$ENQ = EN_addSample ;
  assign inSample$DEQ = WILL_FIRE_RL_costasL_action_l37c17 ;
  assign inSample$CLR = 1'b0 ;

  // submodule outSample
  assign outSample$D_IN = sample ;
  assign outSample$ENQ = WILL_FIRE_RL_costasL_action_l46c18 ;
  assign outSample$DEQ = EN_getFixedSample ;
  assign outSample$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_NOT_IF_error_37_BIT_23_38_THEN_NEG_IF_error_ETC___d158 =
	     (!IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d143[47] &&
	      IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d155[35]) ?
	       36'h7FFFFFFFF :
	       IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d155 ;
  assign IF_NOT_IF_error_37_BIT_23_38_THEN_NEG_IF_error_ETC___d197 =
	     (!IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d182[47] &&
	      IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d194[35]) ?
	       36'h7FFFFFFFF :
	       IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d194 ;
  assign IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d143 =
	     error[23] ?
	       -IF_error_37_BIT_23_38_THEN_NEG_error_37_39_ELS_ETC___d141 :
	       IF_error_37_BIT_23_38_THEN_NEG_error_37_39_ELS_ETC___d141 ;
  assign IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d155 =
	     IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d143[47:12] +
	     { 24'd0, y_f__h37937 } ;
  assign IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d182 =
	     error[23] ?
	       -IF_error_37_BIT_23_38_THEN_NEG_error_37_39_ELS_ETC___d180 :
	       IF_error_37_BIT_23_38_THEN_NEG_error_37_39_ELS_ETC___d180 ;
  assign IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d194 =
	     IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d182[47:12] +
	     { 24'd0, y_f__h40992 } ;
  assign IF_error_37_BIT_23_38_THEN_NEG_error_37_39_ELS_ETC___d141 =
	     x__h40150 * 24'd38 ;
  assign IF_error_37_BIT_23_38_THEN_NEG_error_37_39_ELS_ETC___d180 =
	     x__h40150 * 24'd540 ;
  assign IF_sample_2_BIT_47_8_AND_NOT_sample_2_BIT_23_9_ETC___d113 =
	     x__h34000[47:12] + { 24'd0, y_f__h34893 } ;
  assign IF_sample_2_BIT_47_8_THEN_NEG_sample_2_BITS_47_ETC___d99 =
	     x__h34045 * x__h34064 ;
  assign costasL_abort_whas_AND_costasL_abort_wget_OR_c_ETC___d237 =
	     costasL_state_mkFSMstate == 4'd0 ||
	     phase_0_SLE_6433___d41 && !phase_0_SLT_16770783___d42 &&
	     costasL_state_mkFSMstate == 4'd8 ||
	     phase_0_SLE_6433___d41 && !phase_0_SLT_16770783___d42 &&
	     costasL_state_mkFSMstate == 4'd9 ||
	     !phase_0_SLT_16770783___d42 &&
	     costasL_state_mkFSMstate == 4'd10 ;
  assign phase_0_SLE_6433___d41 = (phase ^ 24'h800000) <= 24'd8395041 ;
  assign phase_0_SLT_16770783___d42 = (phase ^ 24'h800000) < 24'd8382175 ;
  assign x__h33671 =
	     (!x__h34000[47] &&
	      IF_sample_2_BIT_47_8_AND_NOT_sample_2_BIT_23_9_ETC___d113[35]) ?
	       36'h7FFFFFFFF :
	       IF_sample_2_BIT_47_8_AND_NOT_sample_2_BIT_23_9_ETC___d113 ;
  assign x__h34000 =
	     (sample[47] && !sample[23] || sample[23] && !sample[47]) ?
	       -IF_sample_2_BIT_47_8_THEN_NEG_sample_2_BITS_47_ETC___d99 :
	       IF_sample_2_BIT_47_8_THEN_NEG_sample_2_BITS_47_ETC___d99 ;
  assign x__h34045 = sample[47] ? -sample[47:24] : sample[47:24] ;
  assign x__h34064 = sample[23] ? -sample[23:0] : sample[23:0] ;
  assign x__h39380 = phase + freq ;
  assign x__h40150 = error[23] ? -error : error ;
  assign y_f__h34893 =
	     (x__h34000[11] && (x__h34000[47] || x__h34000[10:0] != 11'd0)) ?
	       12'd1 :
	       12'd0 ;
  assign y_f__h37937 =
	     (IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d143[11] &&
	      (IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d143[47] ||
	       IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d143[10:0] !=
	       11'd0)) ?
	       12'd1 :
	       12'd0 ;
  assign y_f__h40992 =
	     (IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d182[11] &&
	      (IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d182[47] ||
	       IF_error_37_BIT_23_38_THEN_NEG_IF_error_37_BIT_ETC___d182[10:0] !=
	       11'd0)) ?
	       12'd1 :
	       12'd0 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        costasL_start_reg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	costasL_start_reg_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	costasL_state_can_overlap <= `BSV_ASSIGNMENT_DELAY 1'd1;
	costasL_state_fired <= `BSV_ASSIGNMENT_DELAY 1'd0;
	costasL_state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY 4'd0;
	error <= `BSV_ASSIGNMENT_DELAY 24'd0;
	freq <= `BSV_ASSIGNMENT_DELAY 24'd0;
	phase <= `BSV_ASSIGNMENT_DELAY 24'd0;
	sample <= `BSV_ASSIGNMENT_DELAY 48'd0;
      end
    else
      begin
        if (costasL_start_reg$EN)
	  costasL_start_reg <= `BSV_ASSIGNMENT_DELAY costasL_start_reg$D_IN;
	if (costasL_start_reg_1$EN)
	  costasL_start_reg_1 <= `BSV_ASSIGNMENT_DELAY
	      costasL_start_reg_1$D_IN;
	if (costasL_state_can_overlap$EN)
	  costasL_state_can_overlap <= `BSV_ASSIGNMENT_DELAY
	      costasL_state_can_overlap$D_IN;
	if (costasL_state_fired$EN)
	  costasL_state_fired <= `BSV_ASSIGNMENT_DELAY
	      costasL_state_fired$D_IN;
	if (costasL_state_mkFSMstate$EN)
	  costasL_state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY
	      costasL_state_mkFSMstate$D_IN;
	if (error$EN) error <= `BSV_ASSIGNMENT_DELAY error$D_IN;
	if (freq$EN) freq <= `BSV_ASSIGNMENT_DELAY freq$D_IN;
	if (phase$EN) phase <= `BSV_ASSIGNMENT_DELAY phase$D_IN;
	if (sample$EN) sample <= `BSV_ASSIGNMENT_DELAY sample$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    costasL_start_reg = 1'h0;
    costasL_start_reg_1 = 1'h0;
    costasL_state_can_overlap = 1'h0;
    costasL_state_fired = 1'h0;
    costasL_state_mkFSMstate = 4'hA;
    error = 24'hAAAAAA;
    freq = 24'hAAAAAA;
    phase = 24'hAAAAAA;
    sample = 48'hAAAAAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_costasL_action_l36c19 &&
	  (WILL_FIRE_RL_costasL_action_l37c17 ||
	   WILL_FIRE_RL_costasL_action_l38c9 ||
	   WILL_FIRE_RL_costasL_action_l42c9 ||
	   WILL_FIRE_RL_costasL_action_l46c18 ||
	   costasL_state_mkFSMstate == 4'd5 ||
	   costasL_state_mkFSMstate == 4'd6 ||
	   costasL_state_mkFSMstate == 4'd7 ||
	   WILL_FIRE_RL_costasL_action_l53c19 ||
	   WILL_FIRE_RL_costasL_action_l57c19))
	$display("Error: \"CostasLoop_optimal.bsv\", line 36, column 19: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_costasL_action_l36c19] and\n  [RL_costasL_action_l37c17, RL_costasL_action_l38c9, RL_costasL_action_l42c9,\n  RL_costasL_action_l46c18, RL_costasL_action_l47c15,\n  RL_costasL_action_l48c14, RL_costasL_action_l49c15,\n  RL_costasL_action_l53c19, RL_costasL_action_l57c19] ) fired in the same\n  clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_costasL_action_l37c17 &&
	  (WILL_FIRE_RL_costasL_action_l38c9 ||
	   WILL_FIRE_RL_costasL_action_l42c9 ||
	   WILL_FIRE_RL_costasL_action_l46c18 ||
	   costasL_state_mkFSMstate == 4'd5 ||
	   costasL_state_mkFSMstate == 4'd6 ||
	   costasL_state_mkFSMstate == 4'd7 ||
	   WILL_FIRE_RL_costasL_action_l53c19 ||
	   WILL_FIRE_RL_costasL_action_l57c19))
	$display("Error: \"CostasLoop_optimal.bsv\", line 37, column 17: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_costasL_action_l37c17] and\n  [RL_costasL_action_l38c9, RL_costasL_action_l42c9, RL_costasL_action_l46c18,\n  RL_costasL_action_l47c15, RL_costasL_action_l48c14,\n  RL_costasL_action_l49c15, RL_costasL_action_l53c19,\n  RL_costasL_action_l57c19] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_costasL_action_l38c9 &&
	  (WILL_FIRE_RL_costasL_action_l42c9 ||
	   WILL_FIRE_RL_costasL_action_l46c18 ||
	   costasL_state_mkFSMstate == 4'd5 ||
	   costasL_state_mkFSMstate == 4'd6 ||
	   costasL_state_mkFSMstate == 4'd7 ||
	   WILL_FIRE_RL_costasL_action_l53c19 ||
	   WILL_FIRE_RL_costasL_action_l57c19))
	$display("Error: \"CostasLoop_optimal.bsv\", line 38, column 9: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_costasL_action_l38c9] and\n  [RL_costasL_action_l42c9, RL_costasL_action_l46c18,\n  RL_costasL_action_l47c15, RL_costasL_action_l48c14,\n  RL_costasL_action_l49c15, RL_costasL_action_l53c19,\n  RL_costasL_action_l57c19] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_costasL_action_l42c9 &&
	  (WILL_FIRE_RL_costasL_action_l46c18 ||
	   costasL_state_mkFSMstate == 4'd5 ||
	   costasL_state_mkFSMstate == 4'd6 ||
	   costasL_state_mkFSMstate == 4'd7 ||
	   WILL_FIRE_RL_costasL_action_l53c19 ||
	   WILL_FIRE_RL_costasL_action_l57c19))
	$display("Error: \"CostasLoop_optimal.bsv\", line 42, column 9: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_costasL_action_l42c9] and\n  [RL_costasL_action_l46c18, RL_costasL_action_l47c15,\n  RL_costasL_action_l48c14, RL_costasL_action_l49c15,\n  RL_costasL_action_l53c19, RL_costasL_action_l57c19] ) fired in the same\n  clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_costasL_action_l46c18 &&
	  (costasL_state_mkFSMstate == 4'd5 ||
	   costasL_state_mkFSMstate == 4'd6 ||
	   costasL_state_mkFSMstate == 4'd7 ||
	   WILL_FIRE_RL_costasL_action_l53c19 ||
	   WILL_FIRE_RL_costasL_action_l57c19))
	$display("Error: \"CostasLoop_optimal.bsv\", line 46, column 18: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_costasL_action_l46c18] and\n  [RL_costasL_action_l47c15, RL_costasL_action_l48c14,\n  RL_costasL_action_l49c15, RL_costasL_action_l53c19,\n  RL_costasL_action_l57c19] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (costasL_state_mkFSMstate == 4'd5 &&
	  (costasL_state_mkFSMstate == 4'd6 ||
	   costasL_state_mkFSMstate == 4'd7 ||
	   WILL_FIRE_RL_costasL_action_l53c19 ||
	   WILL_FIRE_RL_costasL_action_l57c19))
	$display("Error: \"CostasLoop_optimal.bsv\", line 47, column 15: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_costasL_action_l47c15] and\n  [RL_costasL_action_l48c14, RL_costasL_action_l49c15,\n  RL_costasL_action_l53c19, RL_costasL_action_l57c19] ) fired in the same\n  clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (costasL_state_mkFSMstate == 4'd6 &&
	  (costasL_state_mkFSMstate == 4'd7 ||
	   WILL_FIRE_RL_costasL_action_l53c19 ||
	   WILL_FIRE_RL_costasL_action_l57c19))
	$display("Error: \"CostasLoop_optimal.bsv\", line 48, column 14: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_costasL_action_l48c14] and\n  [RL_costasL_action_l49c15, RL_costasL_action_l53c19,\n  RL_costasL_action_l57c19] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (costasL_state_mkFSMstate == 4'd7 &&
	  (WILL_FIRE_RL_costasL_action_l53c19 ||
	   WILL_FIRE_RL_costasL_action_l57c19))
	$display("Error: \"CostasLoop_optimal.bsv\", line 49, column 15: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_costasL_action_l49c15] and\n  [RL_costasL_action_l53c19, RL_costasL_action_l57c19] ) fired in the same\n  clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_costasL_action_l53c19 &&
	  WILL_FIRE_RL_costasL_action_l57c19)
	$display("Error: \"CostasLoop_optimal.bsv\", line 53, column 19: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_costasL_action_l53c19] and\n  [RL_costasL_action_l57c19] ) fired in the same clock cycle.\n");
  end
  // synopsys translate_on
endmodule  // mkCostasLoopO

