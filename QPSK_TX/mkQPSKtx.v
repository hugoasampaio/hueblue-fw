//
// Generated by Bluespec Compiler, version 2021.07 (build 4cac6eb)
//
// On Wed Apr 20 17:42:22 -03 2022
//
//
// Ports:
// Name                         I/O  size props
// get_value                      O    26 reg
// RDY_get_value                  O     1 reg
// RDY_add_sample                 O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// add_sample_bits                I     2 reg
// EN_add_sample                  I     1
// EN_get_value                   I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkQPSKtx(CLK,
		RST_N,

		EN_get_value,
		get_value,
		RDY_get_value,

		add_sample_bits,
		EN_add_sample,
		RDY_add_sample);
  input  CLK;
  input  RST_N;

  // actionvalue method get_value
  input  EN_get_value;
  output [25 : 0] get_value;
  output RDY_get_value;

  // action method add_sample
  input  [1 : 0] add_sample_bits;
  input  EN_add_sample;
  output RDY_add_sample;

  // signals for module outputs
  wire [25 : 0] get_value;
  wire RDY_add_sample, RDY_get_value;

  // inlined wires
  wire tx_sampl_start_wire$whas, tx_sampl_state_set_pw$whas;

  // register input_samples_0
  reg [25 : 0] input_samples_0;
  wire [25 : 0] input_samples_0$D_IN;
  wire input_samples_0$EN;

  // register input_samples_1
  reg [25 : 0] input_samples_1;
  wire [25 : 0] input_samples_1$D_IN;
  wire input_samples_1$EN;

  // register input_samples_2
  reg [25 : 0] input_samples_2;
  wire [25 : 0] input_samples_2$D_IN;
  wire input_samples_2$EN;

  // register input_samples_3
  reg [25 : 0] input_samples_3;
  wire [25 : 0] input_samples_3$D_IN;
  wire input_samples_3$EN;

  // register n
  reg [3 : 0] n;
  wire [3 : 0] n$D_IN;
  wire n$EN;

  // register tx_sampl_start_reg
  reg tx_sampl_start_reg;
  wire tx_sampl_start_reg$D_IN, tx_sampl_start_reg$EN;

  // register tx_sampl_start_reg_1
  reg tx_sampl_start_reg_1;
  wire tx_sampl_start_reg_1$D_IN, tx_sampl_start_reg_1$EN;

  // register tx_sampl_state_can_overlap
  reg tx_sampl_state_can_overlap;
  wire tx_sampl_state_can_overlap$D_IN, tx_sampl_state_can_overlap$EN;

  // register tx_sampl_state_fired
  reg tx_sampl_state_fired;
  wire tx_sampl_state_fired$D_IN, tx_sampl_state_fired$EN;

  // register tx_sampl_state_mkFSMstate
  reg [3 : 0] tx_sampl_state_mkFSMstate;
  reg [3 : 0] tx_sampl_state_mkFSMstate$D_IN;
  wire tx_sampl_state_mkFSMstate$EN;

  // ports of submodule input_bits
  wire [1 : 0] input_bits$D_IN, input_bits$D_OUT;
  wire input_bits$CLR,
       input_bits$DEQ,
       input_bits$EMPTY_N,
       input_bits$ENQ,
       input_bits$FULL_N;

  // ports of submodule mapper
  wire [25 : 0] mapper$map;
  wire [1 : 0] mapper$map_bits;

  // ports of submodule output_sample
  wire [25 : 0] output_sample$D_IN, output_sample$D_OUT;
  wire output_sample$CLR,
       output_sample$DEQ,
       output_sample$EMPTY_N,
       output_sample$ENQ,
       output_sample$FULL_N;

  // ports of submodule srrc
  wire [25 : 0] srrc$add_sample_sample, srrc$get_value;
  wire srrc$EN_add_sample,
       srrc$EN_get_value,
       srrc$RDY_add_sample,
       srrc$RDY_get_value;

  // rule scheduling signals
  wire WILL_FIRE_RL_tx_sampl_action_l29c22,
       WILL_FIRE_RL_tx_sampl_action_l30c19,
       WILL_FIRE_RL_tx_sampl_action_l33c17,
       WILL_FIRE_RL_tx_sampl_action_l34c13,
       WILL_FIRE_RL_tx_sampl_fsm_start,
       WILL_FIRE_RL_tx_sampl_idle_l28c31,
       WILL_FIRE_RL_tx_sampl_idle_l28c31_1;

  // inputs to muxes for submodule ports
  wire [3 : 0] MUX_n$write_1__VAL_1;
  wire MUX_tx_sampl_state_mkFSMstate$write_1__SEL_1;

  // remaining internal signals
  reg [12 : 0] SEL_ARR_input_samples_0_3_BITS_12_TO_0_3_input_ETC___d78,
	       SEL_ARR_input_samples_0_3_BITS_25_TO_13_4_inpu_ETC___d72;
  wire n_8_SLT_4___d39,
       tx_sampl_abort_whas_AND_tx_sampl_abort_wget_OR_ETC___d99;

  // actionvalue method get_value
  assign get_value = output_sample$D_OUT ;
  assign RDY_get_value = output_sample$EMPTY_N ;

  // action method add_sample
  assign RDY_add_sample = input_bits$FULL_N ;

  // submodule input_bits
  FIFO2 #(.width(32'd2), .guarded(1'd1)) input_bits(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(input_bits$D_IN),
						    .ENQ(input_bits$ENQ),
						    .DEQ(input_bits$DEQ),
						    .CLR(input_bits$CLR),
						    .D_OUT(input_bits$D_OUT),
						    .FULL_N(input_bits$FULL_N),
						    .EMPTY_N(input_bits$EMPTY_N));

  // submodule mapper
  mkQPSKmapper mapper(.CLK(CLK),
		      .RST_N(RST_N),
		      .map_bits(mapper$map_bits),
		      .map(mapper$map),
		      .RDY_map());

  // submodule output_sample
  FIFO2 #(.width(32'd26), .guarded(1'd1)) output_sample(.RST(RST_N),
							.CLK(CLK),
							.D_IN(output_sample$D_IN),
							.ENQ(output_sample$ENQ),
							.DEQ(output_sample$DEQ),
							.CLR(output_sample$CLR),
							.D_OUT(output_sample$D_OUT),
							.FULL_N(output_sample$FULL_N),
							.EMPTY_N(output_sample$EMPTY_N));

  // submodule srrc
  mkFIRfilter srrc(.CLK(CLK),
		   .RST_N(RST_N),
		   .add_sample_sample(srrc$add_sample_sample),
		   .EN_add_sample(srrc$EN_add_sample),
		   .EN_get_value(srrc$EN_get_value),
		   .RDY_add_sample(srrc$RDY_add_sample),
		   .get_value(srrc$get_value),
		   .RDY_get_value(srrc$RDY_get_value));

  // rule RL_tx_sampl_action_l30c19
  assign WILL_FIRE_RL_tx_sampl_action_l30c19 =
	     input_bits$EMPTY_N && tx_sampl_state_mkFSMstate == 4'd1 ;

  // rule RL_tx_sampl_action_l33c17
  assign WILL_FIRE_RL_tx_sampl_action_l33c17 =
	     srrc$RDY_add_sample && n_8_SLT_4___d39 &&
	     (tx_sampl_state_mkFSMstate == 4'd3 ||
	      tx_sampl_state_mkFSMstate == 4'd6) ;

  // rule RL_tx_sampl_action_l34c13
  assign WILL_FIRE_RL_tx_sampl_action_l34c13 =
	     srrc$RDY_get_value && output_sample$FULL_N &&
	     tx_sampl_state_mkFSMstate == 4'd4 ;

  // rule RL_tx_sampl_fsm_start
  assign WILL_FIRE_RL_tx_sampl_fsm_start =
	     tx_sampl_abort_whas_AND_tx_sampl_abort_wget_OR_ETC___d99 &&
	     tx_sampl_start_reg ;

  // rule RL_tx_sampl_action_l29c22
  assign WILL_FIRE_RL_tx_sampl_action_l29c22 =
	     input_bits$EMPTY_N &&
	     (tx_sampl_start_wire$whas && tx_sampl_state_mkFSMstate == 4'd0 ||
	      !n_8_SLT_4___d39 && tx_sampl_start_wire$whas &&
	      tx_sampl_state_mkFSMstate == 4'd3 ||
	      !n_8_SLT_4___d39 && tx_sampl_start_wire$whas &&
	      tx_sampl_state_mkFSMstate == 4'd6) ;

  // rule RL_tx_sampl_idle_l28c31
  assign WILL_FIRE_RL_tx_sampl_idle_l28c31 =
	     !n_8_SLT_4___d39 && !tx_sampl_start_wire$whas &&
	     tx_sampl_state_mkFSMstate == 4'd3 ;

  // rule RL_tx_sampl_idle_l28c31_1
  assign WILL_FIRE_RL_tx_sampl_idle_l28c31_1 =
	     !n_8_SLT_4___d39 && !tx_sampl_start_wire$whas &&
	     tx_sampl_state_mkFSMstate == 4'd6 ;

  // inputs to muxes for submodule ports
  assign MUX_tx_sampl_state_mkFSMstate$write_1__SEL_1 =
	     WILL_FIRE_RL_tx_sampl_idle_l28c31_1 ||
	     WILL_FIRE_RL_tx_sampl_idle_l28c31 ;
  assign MUX_n$write_1__VAL_1 = n + 4'd1 ;

  // inlined wires
  assign tx_sampl_start_wire$whas =
	     WILL_FIRE_RL_tx_sampl_fsm_start ||
	     tx_sampl_start_reg_1 && !tx_sampl_state_fired ;
  assign tx_sampl_state_set_pw$whas =
	     WILL_FIRE_RL_tx_sampl_idle_l28c31_1 ||
	     WILL_FIRE_RL_tx_sampl_idle_l28c31 ||
	     tx_sampl_state_mkFSMstate == 4'd5 ||
	     WILL_FIRE_RL_tx_sampl_action_l34c13 ||
	     WILL_FIRE_RL_tx_sampl_action_l33c17 ||
	     tx_sampl_state_mkFSMstate == 4'd2 ||
	     WILL_FIRE_RL_tx_sampl_action_l30c19 ||
	     WILL_FIRE_RL_tx_sampl_action_l29c22 ;

  // register input_samples_0
  assign input_samples_0$D_IN = mapper$map ;
  assign input_samples_0$EN = WILL_FIRE_RL_tx_sampl_action_l29c22 ;

  // register input_samples_1
  assign input_samples_1$D_IN = 26'h0 ;
  assign input_samples_1$EN = 1'b0 ;

  // register input_samples_2
  assign input_samples_2$D_IN = 26'h0 ;
  assign input_samples_2$EN = 1'b0 ;

  // register input_samples_3
  assign input_samples_3$D_IN = 26'h0 ;
  assign input_samples_3$EN = 1'b0 ;

  // register n
  assign n$D_IN =
	     (tx_sampl_state_mkFSMstate == 4'd5) ?
	       MUX_n$write_1__VAL_1 :
	       4'd0 ;
  assign n$EN =
	     tx_sampl_state_mkFSMstate == 4'd5 ||
	     tx_sampl_state_mkFSMstate == 4'd2 ;

  // register tx_sampl_start_reg
  assign tx_sampl_start_reg$D_IN = !WILL_FIRE_RL_tx_sampl_fsm_start ;
  assign tx_sampl_start_reg$EN =
	     WILL_FIRE_RL_tx_sampl_fsm_start ||
	     tx_sampl_abort_whas_AND_tx_sampl_abort_wget_OR_ETC___d99 &&
	     !tx_sampl_start_reg ;

  // register tx_sampl_start_reg_1
  assign tx_sampl_start_reg_1$D_IN = tx_sampl_start_wire$whas ;
  assign tx_sampl_start_reg_1$EN = 1'd1 ;

  // register tx_sampl_state_can_overlap
  assign tx_sampl_state_can_overlap$D_IN =
	     tx_sampl_state_set_pw$whas || tx_sampl_state_can_overlap ;
  assign tx_sampl_state_can_overlap$EN = 1'd1 ;

  // register tx_sampl_state_fired
  assign tx_sampl_state_fired$D_IN = tx_sampl_state_set_pw$whas ;
  assign tx_sampl_state_fired$EN = 1'd1 ;

  // register tx_sampl_state_mkFSMstate
  always@(MUX_tx_sampl_state_mkFSMstate$write_1__SEL_1 or
	  WILL_FIRE_RL_tx_sampl_action_l29c22 or
	  WILL_FIRE_RL_tx_sampl_action_l30c19 or
	  tx_sampl_state_mkFSMstate or
	  WILL_FIRE_RL_tx_sampl_action_l33c17 or
	  WILL_FIRE_RL_tx_sampl_action_l34c13)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_tx_sampl_state_mkFSMstate$write_1__SEL_1:
	  tx_sampl_state_mkFSMstate$D_IN = 4'd0;
      WILL_FIRE_RL_tx_sampl_action_l29c22:
	  tx_sampl_state_mkFSMstate$D_IN = 4'd1;
      WILL_FIRE_RL_tx_sampl_action_l30c19:
	  tx_sampl_state_mkFSMstate$D_IN = 4'd2;
      tx_sampl_state_mkFSMstate == 4'd2:
	  tx_sampl_state_mkFSMstate$D_IN = 4'd3;
      WILL_FIRE_RL_tx_sampl_action_l33c17:
	  tx_sampl_state_mkFSMstate$D_IN = 4'd4;
      WILL_FIRE_RL_tx_sampl_action_l34c13:
	  tx_sampl_state_mkFSMstate$D_IN = 4'd5;
      tx_sampl_state_mkFSMstate == 4'd5:
	  tx_sampl_state_mkFSMstate$D_IN = 4'd6;
      default: tx_sampl_state_mkFSMstate$D_IN =
		   4'b1010 /* unspecified value */ ;
    endcase
  end
  assign tx_sampl_state_mkFSMstate$EN =
	     WILL_FIRE_RL_tx_sampl_idle_l28c31_1 ||
	     WILL_FIRE_RL_tx_sampl_idle_l28c31 ||
	     WILL_FIRE_RL_tx_sampl_action_l29c22 ||
	     WILL_FIRE_RL_tx_sampl_action_l30c19 ||
	     tx_sampl_state_mkFSMstate == 4'd2 ||
	     WILL_FIRE_RL_tx_sampl_action_l33c17 ||
	     WILL_FIRE_RL_tx_sampl_action_l34c13 ||
	     tx_sampl_state_mkFSMstate == 4'd5 ;

  // submodule input_bits
  assign input_bits$D_IN = add_sample_bits ;
  assign input_bits$ENQ = EN_add_sample ;
  assign input_bits$DEQ = WILL_FIRE_RL_tx_sampl_action_l30c19 ;
  assign input_bits$CLR = 1'b0 ;

  // submodule mapper
  assign mapper$map_bits = input_bits$D_OUT ;

  // submodule output_sample
  assign output_sample$D_IN = srrc$get_value ;
  assign output_sample$ENQ = WILL_FIRE_RL_tx_sampl_action_l34c13 ;
  assign output_sample$DEQ = EN_get_value ;
  assign output_sample$CLR = 1'b0 ;

  // submodule srrc
  assign srrc$add_sample_sample =
	     { SEL_ARR_input_samples_0_3_BITS_25_TO_13_4_inpu_ETC___d72,
	       SEL_ARR_input_samples_0_3_BITS_12_TO_0_3_input_ETC___d78 } ;
  assign srrc$EN_add_sample = WILL_FIRE_RL_tx_sampl_action_l33c17 ;
  assign srrc$EN_get_value = WILL_FIRE_RL_tx_sampl_action_l34c13 ;

  // remaining internal signals
  assign n_8_SLT_4___d39 = (n ^ 4'h8) < 4'd12 ;
  assign tx_sampl_abort_whas_AND_tx_sampl_abort_wget_OR_ETC___d99 =
	     (tx_sampl_state_mkFSMstate == 4'd0 ||
	      !n_8_SLT_4___d39 && tx_sampl_state_mkFSMstate == 4'd3 ||
	      !n_8_SLT_4___d39 && tx_sampl_state_mkFSMstate == 4'd6) &&
	     (!tx_sampl_start_reg_1 || tx_sampl_state_fired) ;
  always@(n or
	  input_samples_0 or
	  input_samples_1 or input_samples_2 or input_samples_3)
  begin
    case (n)
      4'd0:
	  SEL_ARR_input_samples_0_3_BITS_25_TO_13_4_inpu_ETC___d72 =
	      input_samples_0[25:13];
      4'd1:
	  SEL_ARR_input_samples_0_3_BITS_25_TO_13_4_inpu_ETC___d72 =
	      input_samples_1[25:13];
      4'd2:
	  SEL_ARR_input_samples_0_3_BITS_25_TO_13_4_inpu_ETC___d72 =
	      input_samples_2[25:13];
      4'd3:
	  SEL_ARR_input_samples_0_3_BITS_25_TO_13_4_inpu_ETC___d72 =
	      input_samples_3[25:13];
      default: SEL_ARR_input_samples_0_3_BITS_25_TO_13_4_inpu_ETC___d72 =
		   13'b0101010101010 /* unspecified value */ ;
    endcase
  end
  always@(n or
	  input_samples_0 or
	  input_samples_1 or input_samples_2 or input_samples_3)
  begin
    case (n)
      4'd0:
	  SEL_ARR_input_samples_0_3_BITS_12_TO_0_3_input_ETC___d78 =
	      input_samples_0[12:0];
      4'd1:
	  SEL_ARR_input_samples_0_3_BITS_12_TO_0_3_input_ETC___d78 =
	      input_samples_1[12:0];
      4'd2:
	  SEL_ARR_input_samples_0_3_BITS_12_TO_0_3_input_ETC___d78 =
	      input_samples_2[12:0];
      4'd3:
	  SEL_ARR_input_samples_0_3_BITS_12_TO_0_3_input_ETC___d78 =
	      input_samples_3[12:0];
      default: SEL_ARR_input_samples_0_3_BITS_12_TO_0_3_input_ETC___d78 =
		   13'b0101010101010 /* unspecified value */ ;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        input_samples_0 <= `BSV_ASSIGNMENT_DELAY 26'd0;
	input_samples_1 <= `BSV_ASSIGNMENT_DELAY 26'd0;
	input_samples_2 <= `BSV_ASSIGNMENT_DELAY 26'd0;
	input_samples_3 <= `BSV_ASSIGNMENT_DELAY 26'd0;
	n <= `BSV_ASSIGNMENT_DELAY 4'd0;
	tx_sampl_start_reg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tx_sampl_start_reg_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tx_sampl_state_can_overlap <= `BSV_ASSIGNMENT_DELAY 1'd1;
	tx_sampl_state_fired <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tx_sampl_state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY 4'd0;
      end
    else
      begin
        if (input_samples_0$EN)
	  input_samples_0 <= `BSV_ASSIGNMENT_DELAY input_samples_0$D_IN;
	if (input_samples_1$EN)
	  input_samples_1 <= `BSV_ASSIGNMENT_DELAY input_samples_1$D_IN;
	if (input_samples_2$EN)
	  input_samples_2 <= `BSV_ASSIGNMENT_DELAY input_samples_2$D_IN;
	if (input_samples_3$EN)
	  input_samples_3 <= `BSV_ASSIGNMENT_DELAY input_samples_3$D_IN;
	if (n$EN) n <= `BSV_ASSIGNMENT_DELAY n$D_IN;
	if (tx_sampl_start_reg$EN)
	  tx_sampl_start_reg <= `BSV_ASSIGNMENT_DELAY tx_sampl_start_reg$D_IN;
	if (tx_sampl_start_reg_1$EN)
	  tx_sampl_start_reg_1 <= `BSV_ASSIGNMENT_DELAY
	      tx_sampl_start_reg_1$D_IN;
	if (tx_sampl_state_can_overlap$EN)
	  tx_sampl_state_can_overlap <= `BSV_ASSIGNMENT_DELAY
	      tx_sampl_state_can_overlap$D_IN;
	if (tx_sampl_state_fired$EN)
	  tx_sampl_state_fired <= `BSV_ASSIGNMENT_DELAY
	      tx_sampl_state_fired$D_IN;
	if (tx_sampl_state_mkFSMstate$EN)
	  tx_sampl_state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY
	      tx_sampl_state_mkFSMstate$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    input_samples_0 = 26'h2AAAAAA;
    input_samples_1 = 26'h2AAAAAA;
    input_samples_2 = 26'h2AAAAAA;
    input_samples_3 = 26'h2AAAAAA;
    n = 4'hA;
    tx_sampl_start_reg = 1'h0;
    tx_sampl_start_reg_1 = 1'h0;
    tx_sampl_state_can_overlap = 1'h0;
    tx_sampl_state_fired = 1'h0;
    tx_sampl_state_mkFSMstate = 4'hA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tx_sampl_action_l30c19 &&
	  (tx_sampl_state_mkFSMstate == 4'd2 ||
	   WILL_FIRE_RL_tx_sampl_action_l33c17 ||
	   WILL_FIRE_RL_tx_sampl_action_l34c13 ||
	   tx_sampl_state_mkFSMstate == 4'd5))
	$display("Error: \"QPSKtx.bsv\", line 30, column 19: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_tx_sampl_action_l30c19] and\n  [RL_tx_sampl_action_f_init_l32c9, RL_tx_sampl_action_l33c17,\n  RL_tx_sampl_action_l34c13, RL_tx_sampl_action_f_update_l32c9] ) fired in the\n  same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (tx_sampl_state_mkFSMstate == 4'd2 &&
	  (WILL_FIRE_RL_tx_sampl_action_l33c17 ||
	   WILL_FIRE_RL_tx_sampl_action_l34c13 ||
	   tx_sampl_state_mkFSMstate == 4'd5))
	$display("Error: \"QPSKtx.bsv\", line 32, column 16: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_tx_sampl_action_f_init_l32c9]\n  and [RL_tx_sampl_action_l33c17, RL_tx_sampl_action_l34c13,\n  RL_tx_sampl_action_f_update_l32c9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tx_sampl_action_l33c17 &&
	  (WILL_FIRE_RL_tx_sampl_action_l34c13 ||
	   tx_sampl_state_mkFSMstate == 4'd5))
	$display("Error: \"QPSKtx.bsv\", line 33, column 17: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_tx_sampl_action_l33c17] and\n  [RL_tx_sampl_action_l34c13, RL_tx_sampl_action_f_update_l32c9] ) fired in\n  the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tx_sampl_action_l34c13 &&
	  tx_sampl_state_mkFSMstate == 4'd5)
	$display("Error: \"QPSKtx.bsv\", line 34, column 13: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_tx_sampl_action_l34c13] and\n  [RL_tx_sampl_action_f_update_l32c9] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tx_sampl_action_l29c22 &&
	  (WILL_FIRE_RL_tx_sampl_action_l30c19 ||
	   tx_sampl_state_mkFSMstate == 4'd2 ||
	   WILL_FIRE_RL_tx_sampl_action_l33c17 ||
	   WILL_FIRE_RL_tx_sampl_action_l34c13 ||
	   tx_sampl_state_mkFSMstate == 4'd5))
	$display("Error: \"QPSKtx.bsv\", line 29, column 22: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_tx_sampl_action_l29c22] and\n  [RL_tx_sampl_action_l30c19, RL_tx_sampl_action_f_init_l32c9,\n  RL_tx_sampl_action_l33c17, RL_tx_sampl_action_l34c13,\n  RL_tx_sampl_action_f_update_l32c9] ) fired in the same clock cycle.\n");
  end
  // synopsys translate_on
endmodule  // mkQPSKtx

