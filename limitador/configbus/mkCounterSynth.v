//
// Generated by Bluespec Compiler, version 2023.01-6-g034050db (build 034050db)
//
// On Fri Apr 14 15:27:30 -03 2023
//
//
// Ports:
// Name                         I/O  size props
// RDY_cbus_ifc_write             O     1 const
// cbus_ifc_read                  O    33
// RDY_cbus_ifc_read              O     1 const
// device_ifc_isZero              O     1
// RDY_device_ifc_isZero          O     1 const
// RDY_device_ifc_decrement       O     1 const
// RDY_device_ifc_load            O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// cbus_ifc_write_addr            I    10
// cbus_ifc_write_data            I    32
// cbus_ifc_read_addr             I    10
// device_ifc_load_newval         I     8
// EN_cbus_ifc_write              I     1
// EN_device_ifc_decrement        I     1
// EN_device_ifc_load             I     1
//
// Combinational paths from inputs to outputs:
//   cbus_ifc_read_addr -> cbus_ifc_read
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkCounterSynth(CLK,
		      RST_N,

		      cbus_ifc_write_addr,
		      cbus_ifc_write_data,
		      EN_cbus_ifc_write,
		      RDY_cbus_ifc_write,

		      cbus_ifc_read_addr,
		      cbus_ifc_read,
		      RDY_cbus_ifc_read,

		      device_ifc_isZero,
		      RDY_device_ifc_isZero,

		      EN_device_ifc_decrement,
		      RDY_device_ifc_decrement,

		      device_ifc_load_newval,
		      EN_device_ifc_load,
		      RDY_device_ifc_load);
  input  CLK;
  input  RST_N;

  // action method cbus_ifc_write
  input  [9 : 0] cbus_ifc_write_addr;
  input  [31 : 0] cbus_ifc_write_data;
  input  EN_cbus_ifc_write;
  output RDY_cbus_ifc_write;

  // value method cbus_ifc_read
  input  [9 : 0] cbus_ifc_read_addr;
  output [32 : 0] cbus_ifc_read;
  output RDY_cbus_ifc_read;

  // value method device_ifc_isZero
  output device_ifc_isZero;
  output RDY_device_ifc_isZero;

  // action method device_ifc_decrement
  input  EN_device_ifc_decrement;
  output RDY_device_ifc_decrement;

  // action method device_ifc_load
  input  [7 : 0] device_ifc_load_newval;
  input  EN_device_ifc_load;
  output RDY_device_ifc_load;

  // signals for module outputs
  wire [32 : 0] cbus_ifc_read;
  wire RDY_cbus_ifc_read,
       RDY_cbus_ifc_write,
       RDY_device_ifc_decrement,
       RDY_device_ifc_isZero,
       RDY_device_ifc_load,
       device_ifc_isZero;

  // register counter
  reg [7 : 0] counter;
  reg [7 : 0] counter$D_IN;
  wire counter$EN;

  // inputs to muxes for submodule ports
  wire [7 : 0] MUX_counter$write_1__VAL_3;
  wire MUX_counter$write_1__SEL_2;

  // action method cbus_ifc_write
  assign RDY_cbus_ifc_write = 1'd1 ;

  // value method cbus_ifc_read
  assign cbus_ifc_read = { cbus_ifc_read_addr == 10'd13, 24'd0, counter } ;
  assign RDY_cbus_ifc_read = 1'd1 ;

  // value method device_ifc_isZero
  assign device_ifc_isZero = counter == 8'd0 ;
  assign RDY_device_ifc_isZero = 1'd1 ;

  // action method device_ifc_decrement
  assign RDY_device_ifc_decrement = 1'd1 ;

  // action method device_ifc_load
  assign RDY_device_ifc_load = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_counter$write_1__SEL_2 =
	     EN_cbus_ifc_write && cbus_ifc_write_addr == 10'd13 ;
  assign MUX_counter$write_1__VAL_3 = counter - 8'd1 ;

  // register counter
  always@(EN_device_ifc_load or
	  device_ifc_load_newval or
	  MUX_counter$write_1__SEL_2 or
	  cbus_ifc_write_data or
	  EN_device_ifc_decrement or MUX_counter$write_1__VAL_3)
  case (1'b1)
    EN_device_ifc_load: counter$D_IN = device_ifc_load_newval;
    MUX_counter$write_1__SEL_2: counter$D_IN = cbus_ifc_write_data[7:0];
    EN_device_ifc_decrement: counter$D_IN = MUX_counter$write_1__VAL_3;
    default: counter$D_IN = 8'b10101010 /* unspecified value */ ;
  endcase
  assign counter$EN =
	     EN_cbus_ifc_write && cbus_ifc_write_addr == 10'd13 ||
	     EN_device_ifc_load ||
	     EN_device_ifc_decrement ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        counter <= `BSV_ASSIGNMENT_DELAY 8'd0;
      end
    else
      begin
        if (counter$EN) counter <= `BSV_ASSIGNMENT_DELAY counter$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    counter = 8'hAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkCounterSynth

